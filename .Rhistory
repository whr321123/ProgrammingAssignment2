m
## 1.set the value of the matrix
## 2.get the value of the matrix
## 3.set the inverse of the input matrix
## 4.get the inverse of the input matrix
makeCacheMatrix <- function(x = matrix()) {
m<-NULL
set<-function(y){
x<<-y
m<<-NULL
}
get<-function() x
setinverse<-function(inverse_) m<<- inverse_
getinverse<-function() m
list(set=set,get=get,setinverse=setinverse,getinverse=getinverse)
}
## The following function calculates the inverse of the special "matrix" created with the above function.
## However, it first checks to see if the inverse has already been calculated.
## If so, it gets the inverse from the cache and skips the computation.
## Otherwise, it calculates the inverse of the matrix and sets the inverse matrix in the cache via the setinverse function.
cacheSolve <- function(x, ...) {
m<-x$getinverse()
if (!is.null(m)){
message("getting cached inverse matrix!")
return (m)
}
data<-x$get()
m<-solve(data)
x$setinverse(m)
m
## Return a matrix that is the inverse of 'x'
}
a<-matrix(1:4,2,2)
cacheSolve(a)
makeCacheMatrix()
makeCacheMatrix(a)
cacheSolve(a)
makeVector <- function(x = numeric()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setmean <- function(mean) m <<- mean
getmean <- function() m
list(set = set, get = get,
setmean = setmean,
getmean = getmean)
}
makeVector <- function(x = numeric()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setmean <- function(mean) m <<- mean
getmean <- function() m
list(set = set, get = get,
setmean = setmean,
getmean = getmean)
}
makeVector <- function(x = numeric()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setmean <- function(mean) m <<- mean
getmean <- function() m
list(set = set, get = get,
setmean = setmean,
getmean = getmean)
}
cachemean <- function(x, ...) {
m <- x$getmean()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- mean(data, ...)
x$setmean(m)
m
}
cachemean(c(4,5,6))
makeVector(1:7)
cachemean(c(1:7))
x<-1:10
xx<-makeVector(x)
xx$getmean()
xx$setmean(4)
xx$getmean()
a
makeCacheMatrix(a)
b<-makeCacheMatrix(a)
b$get()
cacheSlove(makeCacheMatrix(a))
cacheSolve(makeCacheMatrix(a))
cacheSolve(makeCacheMatrix(a))
cacheSolve(makeCacheMatrix(a))
## Put comments here that give an overall description of what your
## functions do
##  The first function, makeCacheMatrix creates a special matrix, which is really a list containing a function to
## 1.set the value of the matrix
## 2.get the value of the matrix
## 3.set the inverse of the input matrix
## 4.get the inverse of the input matrix
makeCacheMatrix <- function(x = matrix()) {
m<-NULL
set<-function(y){
x<<-y
m<<-NULL
}
get<-function() x
setinverse<-function(inverse_) m<<- inverse_
getinverse<-function() m
list(set=set,get=get,setinverse=setinverse,getinverse=getinverse)
}
## The following function calculates the inverse of the special "matrix" created with the above function.
## However, it first checks to see if the inverse has already been calculated.
## If so, it gets the inverse from the cache and skips the computation.
## Otherwise, it calculates the inverse of the matrix and sets the inverse matrix in the cache via the setinverse function.
cacheSolve <- function(x, ...) {
m<-x$getinverse()
if (!is.null(m)){
message("getting cached inverse matrix!")
print ("aaa!")
return (m)
}
data<-x$get()
m<-solve(data)
x$setinverse(m)
m
## Return a matrix that is the inverse of 'x'
}
## Put comments here that give an overall description of what your
## functions do
##  The first function, makeCacheMatrix creates a special matrix, which is really a list containing a function to
## 1.set the value of the matrix
## 2.get the value of the matrix
## 3.set the inverse of the input matrix
## 4.get the inverse of the input matrix
makeCacheMatrix <- function(x = matrix()) {
m<-NULL
set<-function(y){
x<<-y
m<<-NULL
}
get<-function() x
setinverse<-function(inverse_) m<<- inverse_
getinverse<-function() m
list(set=set,get=get,setinverse=setinverse,getinverse=getinverse)
}
## The following function calculates the inverse of the special "matrix" created with the above function.
## However, it first checks to see if the inverse has already been calculated.
## If so, it gets the inverse from the cache and skips the computation.
## Otherwise, it calculates the inverse of the matrix and sets the inverse matrix in the cache via the setinverse function.
cacheSolve <- function(x, ...) {
m<-x$getinverse()
if (!is.null(m)){
message("getting cached inverse matrix!")
print ("aaa!")
return (m)
}
data<-x$get()
m<-solve(data)
x$setinverse(m)
m
## Return a matrix that is the inverse of 'x'
}
fd
cacheSolve(makeCacheMatrix(a))
cacheSolve(makeCacheMatrix(a))
cacheSolve(makeCacheMatrix(a))
cacheSolve(makeCacheMatrix(a))
?message
x
x<-makeCacheMatrix(a)
x
cacheSolve(x)
cacheSolve(x)
cacheSolve(x)
a<-matrix(1:4,2,2)
x<-makeCacheMatrix(a)
## Put comments here that give an overall description of what your
## functions do
##  The first function, makeCacheMatrix creates a special matrix, which is really a list containing a function to
## 1.set the value of the matrix
## 2.get the value of the matrix
## 3.set the inverse of the input matrix
## 4.get the inverse of the input matrix
makeCacheMatrix <- function(x = matrix()) {
m<-NULL
set<-function(y){
x<<-y
m<<-NULL
}
get<-function() x
setinverse<-function(inverse_) m<<- inverse_
getinverse<-function() m
list(set=set,get=get,setinverse=setinverse,getinverse=getinverse)
}
## The following function calculates the inverse of the special "matrix" created with the above function.
## However, it first checks to see if the inverse has already been calculated.
## If so, it gets the inverse from the cache and skips the computation.
## Otherwise, it calculates the inverse of the matrix and sets the inverse matrix in the cache via the setinverse function.
cacheSolve <- function(x, ...) {
m<-x$getinverse()
if (!is.null(m)){
message("getting cached inverse matrix!")
return (m)
}
data<-x$get()
m<-solve(data)
x$setinverse(m)
m
## Return a matrix that is the inverse of 'x'
}
x<-makeCacheMatrix(a)
cacheSolve(x)
cacheSolve(x)
